
export class MaterialRipple
{
	CssClasses_ = {
		RIPPLE_CENTER: 'mdl-ripple--center',
		RIPPLE_EFFECT_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
		RIPPLE: 'mdl-ripple',
		IS_ANIMATING: 'is-animating',
		IS_VISIBLE: 'is-visible'
	};
	Constant_ = {
		INITIAL_SCALE: 'scale(0.0001, 0.0001)',
		INITIAL_SIZE: '1px',
		INITIAL_OPACITY: '0.4',
		FINAL_OPACITY: '0',
		FINAL_SCALE: ''
	};
	frameCount_: number;
	ignoringMouseDown_: boolean;
	rippleElement_: any;
	rippleSize_: number;
	x_: number;
	y_: number;

	boundHeight: number;
	boundWidth: number;
	boundDownHandler: Function;
	boundUpHandler: Function;

	animFrameHandler: Function;
	getFrameCount: Function;
	setFrameCount: Function;
	getRippleElement: Function;
	setRippleStyles: Function;
	setRippleXY: Function;

	constructor(
		public renderer_: any,
		public element_: any
	) {
		// Initialize instance.
		this.init();
	}

	downHandler_(event: any)
	{
		if (!this.rippleElement_.style.width && !this.rippleElement_.style.height) {
			var rect = this.element_.getBoundingClientRect();
			this.boundHeight = rect.height;
			this.boundWidth = rect.width;
			this.rippleSize_ = Math.sqrt(rect.width * rect.width +
				rect.height * rect.height) * 2 + 2;
			this.rippleElement_.style.width = this.rippleSize_ + 'px';
			this.rippleElement_.style.height = this.rippleSize_ + 'px';
		}

		this.renderer_.addClass(this.rippleElement_, this.CssClasses_.IS_VISIBLE);

		if (event.type === 'mousedown' && this.ignoringMouseDown_) {
			this.ignoringMouseDown_ = false;
		}
		else {
			if (event.type === 'touchstart') {
				this.ignoringMouseDown_ = true;
			}
			var frameCount = this.getFrameCount();
			if (frameCount > 0) {
				return;
			}
			this.setFrameCount(1);
			var bound = event.currentTarget.getBoundingClientRect();
			var x;
			var y;
			// Check if we are handling a keyboard click.
			if (event.clientX === 0 && event.clientY === 0) {
				x = Math.round(bound.width / 2);
				y = Math.round(bound.height / 2);
			} else {
				var clientX = event.clientX !== undefined  ? event.clientX : event.touches[0].clientX;
				var clientY = event.clientY !== undefined  ? event.clientY : event.touches[0].clientY;
				x = Math.round(clientX - bound.left);
				y = Math.round(clientY - bound.top);
			}
			this.setRippleXY(x, y);
			this.setRippleStyles(true);
			window.requestAnimationFrame(this.animFrameHandler.bind(this));
		}
	}

	upHandler_(event: any)
	{
		// Don't fire for the artificial "mouseup" generated by a double-click.
		if (event && event.detail !== 2) {
			// Allow a repaint to occur before removing this class, so the animation
			// shows for tap events, which seem to trigger a mouseup too soon after
			// mousedown.
			setTimeout(() => {
				this.renderer_.removeClass(this.rippleElement_, this.CssClasses_.IS_VISIBLE);
			}, 0);
		}
	}

	init()
	{
		if (this.element_) {
			var recentering = this.element_.classList.contains(this.CssClasses_.RIPPLE_CENTER);

			if (
				! this.element_.classList.contains(
					this.CssClasses_.RIPPLE_EFFECT_IGNORE_EVENTS
				)
			) {
				this.rippleElement_ = this.element_.querySelector(
					'.' +
					this.CssClasses_.RIPPLE
				);
				this.frameCount_ = 0;
				this.rippleSize_ = 0;
				this.x_ = 0;
				this.y_ = 0;

				// Touch start produces a compat mouse down event, which would cause a
				// second ripples. To avoid that, we use this property to ignore the first
				// mouse down after a touch start.
				this.ignoringMouseDown_ = false;

				this.boundDownHandler = this.downHandler_.bind(this);
				this.element_.addEventListener('mousedown', this.boundDownHandler);
				this.element_.addEventListener('touchstart', this.boundDownHandler);

				this.boundUpHandler = this.upHandler_.bind(this);
				this.element_.addEventListener('mouseup', this.boundUpHandler);
				this.element_.addEventListener('mouseleave', this.boundUpHandler);
				this.element_.addEventListener('touchend', this.boundUpHandler);
				this.element_.addEventListener('blur', this.boundUpHandler);

				/**
				 * Getter for frameCount_.
				 * @return {number} the frame count.
				 */
				this.getFrameCount = () => {
					return this.frameCount_;
				};

				/**
				 * Setter for frameCount_.
				 * @param {number} fC the frame count.
				 */
				this.setFrameCount = (fC: any) => {
					this.frameCount_ = fC;
				};

				/**
				 * Getter for rippleElement_.
				 * @return {Element} the ripple element.
				 */
				this.getRippleElement = () => {
					return this.rippleElement_;
				};

				/**
				 * Sets the ripple X and Y coordinates.
				 * @param  {number} newX the new X coordinate
				 * @param  {number} newY the new Y coordinate
				 */
				this.setRippleXY = (newX: number, newY: number) => {
					this.x_ = newX;
					this.y_ = newY;
				};

				/**
				 * Sets the ripple styles.
				 * @param  {boolean} start whether or not this is the start frame.
				 */
				this.setRippleStyles = (start: any) => {
					if (this.rippleElement_ !== null) {
						var transformString;
						var scale;
						// TODO: Confirm safe removal of `MaterialRipple.setRippleStyles size`
						// var size;
						var offset = 'translate(' + this.x_ + 'px, ' + this.y_ + 'px)';

						if (start) {
							scale = this.Constant_.INITIAL_SCALE;
							// size = this.Constant_.INITIAL_SIZE;
						} else {
							scale = this.Constant_.FINAL_SCALE;
							// size = this.rippleSize_ + 'px';
							if (recentering) {
								offset = 'translate(' + this.boundWidth / 2 + 'px, ' +
									this.boundHeight / 2 + 'px)';
							}
						}

						transformString = 'translate(-50%, -50%) ' + offset + scale;

						this.rippleElement_.style.webkitTransform = transformString;
						this.rippleElement_.style.msTransform = transformString;
						this.rippleElement_.style.transform = transformString;

						if(start) {
							this.renderer_.removeClass(this.rippleElement_, this.CssClasses_.IS_ANIMATING);
						} else {
							this.renderer_.addClass(this.rippleElement_, this.CssClasses_.IS_ANIMATING);
						}

					}
				};

				/**
				 * Handles an animation frame.
				 */
				this.animFrameHandler = () => {
					if (this.frameCount_-- > 0) {
						window.requestAnimationFrame(this.animFrameHandler.bind(this));
					} else {
						this.setRippleStyles(false);
					}
				};
			}
		}
	}
}
